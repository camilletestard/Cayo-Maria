paste("GlobalNetworkMetrics",groupyear[gy],"pdf",sep = ".")
groupyear = c("V.2015","V.2016","V.2017","KK.2015","KK.2017")
for (gy in 1:length(groupyear)){ #For each group
name.0 = paste(groupyear[gy],".0",sep="")
data.0 = AllStats[[name.0]]; data.0$isPost = 0
name.1 = paste(groupyear[gy],".1",sep="")
data.1 = AllStats[[name.1]]; data.1$isPost = 1
data= rbind(data.0, data.1)
pdf(file= paste("GlobalNetworkMetrics",groupyear[gy],"pdf",sep = "."), width=5, height=5, onefile = T) #width and height of the graphics region in inches. One file if true = multiple graphs in one file
#hist(data.0$dens); hist(data.1$dens)
{density <- ggplot(data, aes(x= as.factor(isPost), y=dens, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("Density of social network pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Density of social network")}
#ylim(0,0.4)
# print(density)
# readline(prompt = "pause ")
#hist(data.0$gini); hist(data.1$gini)
{equity <- ggplot(data, aes(x= as.factor(isPost), y=gini, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("Equity of social network pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Gini coeff relative to baseline")}
#ylim(0,0.9)
# print(equity)
# readline(prompt = "pause ")
}
library(ggplot2)
load("C:/Users/Camille Testard/Documents/GitHub/Cayo-Maria/Social_Network_Analysis/AllStats4.RData")
##########################################################
#Sex partner preference
##########################################################
groupyear = c("V.2015","V.2016","V.2017","KK.2015","KK.2017")
for (gy in 1:length(groupyear)){ #For each group
name.0 = paste(groupyear[gy],".0",sep="")
data.0 = AllStats[[name.0]]; data.0$isPost = 0
name.1 = paste(groupyear[gy],".1",sep="")
data.1 = AllStats[[name.1]]; data.1$isPost = 1
data= rbind(data.0, data.1)
pdf(file= paste("SexPartnerPref",groupyear[gy],"pdf",sep = "."), width=5, height=5, onefile = T)
{FFpair <- ggplot(data, aes(x= as.factor(isPost), y=eo.FF, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("FF Pair preference pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Obs./Exp. FF")}
#ylim(0,0.4)
# print(FFpair)
# readline(prompt = "pause ")
{MMpair <- ggplot(data, aes(x= as.factor(isPost), y=eo.MM, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("MM Pair preference pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Obs./Exp. MM")}
#ylim(0,0.4)
# print(MMpair)
# readline(prompt = "pause ")
{crosspair <- ggplot(data, aes(x= as.factor(isPost), y=eo.cross, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("Cross Pair preference pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Obs./Exp. Cross")}
#ylim(0,0.4)
# print(crosspair)
# readline(prompt = "pause ")
}
##########################################################
#Kinship preference
##########################################################
for (gy in 1:length(groupyear)){ #For each group
name.0 = paste(groupyear[gy],".0",sep="")
data.0 = AllStats[[name.0]]; data.0$isPost = 0
name.1 = paste(groupyear[gy],".1",sep="")
data.1 = AllStats[[name.1]]; data.1$isPost = 1
data= rbind(data.0, data.1)
pdf(file= paste("KinshipPartnerPref",groupyear[gy],"pdf",sep = "."), width=5, height=5, onefile = T)
CKpair <- ggplot(data, aes(x= as.factor(isPost), y=eo.ck, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("Close Kin Pair preference pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Obs./Exp. Close Kin")
#ylim(0,0.4)
print(CKpair)
readline(prompt = "pause ")
DKpair <- ggplot(data, aes(x= as.factor(isPost), y=eo.dk, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("Distant Kin Pair preference pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Obs./Exp. Distant Kin")
#ylim(0,0.4)
print(DKpair)
readline(prompt = "pause ")
Upair <- ggplot(data, aes(x= as.factor(isPost), y=eo.u, fill=as.factor(isPost) ))+
geom_boxplot()+
geom_jitter(position = position_jitter(0.2), alpha = 0.5)+
ggtitle(paste("Unrelated Pair preference pre- vs. post- hurricane ",groupyear[gy],sep=""))+
labs(fill = "Hurricane Status",x="Hurricane Status",y="Obs./Exp. Unrelated")
#ylim(0,0.4)
print(Upair)
readline(prompt = "pause ")
}
library(lme4)# Generalized Linear Mixed Models
library(lmerTest)
library(performance)
#library(sjPlot)
#library(glmmTMB)# Generalized Linear Mixed Models, other package
#library(MCMCglmm)# Generalized Linear Mixed Models, other package
#library(bbmle)#Tools for General Maximum Likelihood Estimation
#library(DHARMa) #residual diagnostic fr hierarchical (multi-level/mixed) regression models
#Load data
load("C:/Users/Camille Testard/Documents/GitHub/Cayo-Maria/Social_Network_Analysis/SocialCapital.dSocialRates.RData")
#Format data correclty
SocialCapital.ALL$sex = as.factor(SocialCapital.ALL$sex); SocialCapital.ALL$age = as.numeric(SocialCapital.ALL$age); SocialCapital.ALL$group = as.factor(SocialCapital.ALL$group)
data = SocialCapital.ALL[-which(is.na(SocialCapital.ALL$dpAcc)),] #remove NA
#check distribution of independent variables
hist(data$dpAcc); hist(data$dpSocial, add=T)
#Scale parameters:
data[,c("age","GroomIN","GroomOUT","AggIN","AggOUT","vig.ra","sdb.ra")] <- scale(data[,c("age","GroomIN","GroomOUT","AggIN","AggOUT","vig.ra","sdb.ra")])
## Model Social Capital effect on change in sociliaty rates
#Modelling change in p(Acc)
dpAcc1 <- lmer(dpAcc~ sex + age + group + rank + (1|id) + (1|year), data = data)
summary(dpAcc1)
tab_model(dpAcc1)
install.packages("tsna",dependencies = T)
install.packages("ndtv",dependencies = T)
#load required packages
library(network)
library(ergm)
library(dplyr)
# library(sna)
# library(igraph)
# library(tnet)
library(stringr)
library(ggplot2)
library(statnet)
library(ndtv)
library(htmlwidgets)
library(latticeExtra)
# http://statnet.org/Workshops/ergm_tutorial.html#appendix_a:_clarifying_the_terms_%E2%80%93_ergm_and_network
# http://statnet.org/Workshops/tergm_tutorial.html
#load local functions
setwd("C:/Users/Camille Testard/Documents/GitHub/Cayo-Maria/cleaned_code/functions")
source("CalcSubsampledScans.R")
source("functions_Homophily.R")
source("KinshipPedigree.R")
#Load scan data, population and dominance info
setwd("C:/Users/Camille Testard/Desktop/Desktop-Cayo-Maria/")
allScans = read.csv("Behavioral_Data/Data All Cleaned/allScans2019.txt")
bigped <- read.delim("Behavioral_Data/SubjectInfo_2010-2017/PEDIGREE.txt", sep="\t")
setwd("C:/Users/Camille Testard/Documents/GitHub/Cayo-Maria/")
load("R.Data/SocialCapital.RData")
SocialCapital.ALL$groupyear = paste(SocialCapital.ALL$group, SocialCapital.ALL$year,sep="")
#Compute pedigree for all IDs in this group
allIDs= allScans$focalID[which(allScans$group == "KK"|allScans$group == "V")];
# groupIDs = as.character(unique(allIDs))
# IDmatch = match(groupIDs, as.character(bigped$ID)); discard.na = which(is.na(IDmatch))
# if(length(discard.na)!=0)
# {pedigree = bigped[IDmatch[-discard.na],c("ID","DAM","SIRE")]
# } else {pedigree = bigped[IDmatch,c("ID","DAM","SIRE")]}
pedigree=bigped
ped <- KinshipPedigree(pedigree)
num_iter = 50
#For each group, each year separately:
group = c("V","V","V","KK","KK") #c("V","V","V","V","V","KK","KK","KK","S")
years = c(2015, 2016,2017,2015, 2017)#c(2015,2016,2017,2018, 2019, 2015, 2017, 2018, 2019)
groupyears =c("V2015","V2016","V2017","KK2015","KK2017") #c("V2015","V2016","V2017","V2018","V2019","KK2015","KK2017","KK2018", "S2019")
TERGMeffects = data.frame(); TERGMeffects.ALL=data.frame(); count=0
start_time <- Sys.time(); iter=1; a=1; gy=1
# 1. Calculate random subsamples
randomScans = calcRandomScans(allScans)
randomScans$groupyear = paste(randomScans$group, randomScans$year,sep="")
# 2. For each group, each year and pre-/post-hurr separately, compute weighted edge list:
gy=1
randscansY = randomScans[which(randomScans$groupyear==groupyears[gy]),] #subselect scans of group G
isPost = c(0,1); h=1
rscans = randscansY[which(randscansY$isPost==isPost[h]),] #subselect scans of group G, year Y and hurricane status H
numscans = as.data.frame(table(as.character(rscans$focalID))); names(numscans) =c("id","freq")
#Find all unique IDs
unqIDs = unique(as.character(rscans$focalID))
# Output the Master Edgelist of all possible pairs given the unique IDs.
masterEL = calcMasterEL_groom(unqIDs)
# Output weighted edgelist from the Master Edgelist.
options(warn = -1) #set options to ignore all warnings
weightedEL.prox = calcEdgeList(rscans,masterEL)
weightedEL.prox$numscans <- (numscans$freq[match(weightedEL.prox$givingID, numscans$id)] + numscans$freq[match(weightedEL.prox$receivingID, numscans$id)])/2
weightedEL.prox$weight <- round(weightedEL.prox$count / weightedEL.prox$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.prox$weight[weightedEL.prox$weight>0]) #compute nonzero mean weight
weightedEL.prox$weight <- weightedEL.prox$weight/meanweight
el.prox = weightedEL.prox[,c("givingID","receivingID",'weight'),];
weightedEL.groom = calcEdgeList_groom(rscans,masterEL)
weightedEL.groom = weightedEL.groom[,c("givingID","receivingID","count")]
weightedEL.groom$conc = paste(weightedEL.groom$givingID, weightedEL.groom$receivingID, sep=".")
weightedEL.groom$numscans <- (numscans$freq[match(weightedEL.groom$givingID, numscans$id)] + numscans$freq[match(weightedEL.groom$receivingID, numscans$id)])/2
weightedEL.groom$weight <- round(weightedEL.groom$count / weightedEL.groom$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.groom$weight[weightedEL.groom$weight>0]) #compute nonzero mean weight
weightedEL.groom$weight <- weightedEL.groom$weight/meanweight
el = weightedEL.groom[,c("givingID","receivingID",'weight'),]; #newP[,c("givingID","receivingID",'count'),]
adjMat = dils::AdjacencyFromEdgelist(el)# create adjacency matrix based on edge list.
mat = adjMat[["adjacency"]]; rownames(mat) = adjMat[["nodelist"]]; colnames(mat) = adjMat[["nodelist"]]
net<-as.network.matrix(mat,loops=FALSE,directed=T)
KC      <- NULL; for(i in 1:length(el[,1])){
KC[i] <-  ped[which(rownames(ped)==as.character(el$receivingID[i])) , which(colnames(ped)==as.character(el$givingID[i]))]
}
set.edge.attribute(net, "kinship", ,KC)
set.edge.attribute(net, "kinship",KC)
net
KC
hist(KC)
KC!=0
which(KC!=0)
which(ped!=0)
i=1
as.character(el$receivingID[i]))
as.character(el$receivingID[i])
rownames(ped)==as.character(el$receivingID[i])
which(rownames(ped)==as.character(el$receivingID[i]))
which(colnames(ped)==as.character(el$givingID[i]))
ped[which(rownames(ped)==as.character(el$receivingID[i])) , which(colnames(ped)==as.character(el$givingID[i]))]
View(el)
as.character(el$receivingID[i]))
as.character(el$receivingID[i])
View(el)
View(bigped)
View(pedigree)
pedigree=bigped[,c("ID","DAM","SIRE")]
View(pedigree)
ped <- KinshipPedigree(pedigree)
pedigree=bigped[,c("ID","DAM","SIRE")]
ped <- KinshipPedigree(pedigree)
KC      <- NULL; for(i in 1:length(el[,1])){
KC[i] <-  ped[which(rownames(ped)==as.character(el$receivingID[i])) , which(colnames(ped)==as.character(el$givingID[i]))]
}
hist(KC)
set.edge.attribute(net, "kinship",KC)
which(el.prox$givingID==el$givingID[i])
el.prox$weight[which(el.prox$givingID==el$givingID[i]), which(el.prox$receivingID==el$receivingID[i])]
which(el.prox$givingID==el$givingID[i] & el.prox$receivingID==el$receivingID[i])
el.prox$weight[which(el.prox$givingID==el$givingID[i] & el.prox$receivingID==el$receivingID[i])]
prox <-NULL; for(i in 1:nrow(el)){
prox[i]<- el.prox$weight[which(el.prox$givingID==el$givingID[i] & el.prox$receivingID==el$receivingID[i])]
}
hist(prox)
set.edge.attribute(net, "prox",prox)
isPost = c(0,1); h=1
for (h in 1:length(isPost)){ #pre- and post-hurricane
rscans = randscansY[which(randscansY$isPost==isPost[h]),] #subselect scans of group G, year Y and hurricane status H
numscans = as.data.frame(table(as.character(rscans$focalID))); names(numscans) =c("id","freq")
#Find all unique IDs
unqIDs = unique(as.character(rscans$focalID))
# Output the Master Edgelist of all possible pairs given the unique IDs.
masterEL = calcMasterEL_groom(unqIDs)
# Output weighted edgelist from the Master Edgelist.
options(warn = -1) #set options to ignore all warnings
weightedEL.prox = calcEdgeList(rscans,masterEL)
weightedEL.prox$numscans <- (numscans$freq[match(weightedEL.prox$givingID, numscans$id)] + numscans$freq[match(weightedEL.prox$receivingID, numscans$id)])/2
weightedEL.prox$weight <- round(weightedEL.prox$count / weightedEL.prox$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.prox$weight[weightedEL.prox$weight>0]) #compute nonzero mean weight
weightedEL.prox$weight <- weightedEL.prox$weight/meanweight
el.prox = weightedEL.prox[,c("givingID","receivingID",'weight'),];
#for grooming network
weightedEL.groom = calcEdgeList_groom(rscans,masterEL)
weightedEL.groom = weightedEL.groom[,c("givingID","receivingID","count")]
weightedEL.groom$conc = paste(weightedEL.groom$givingID, weightedEL.groom$receivingID, sep=".")
weightedEL.groom$numscans <- (numscans$freq[match(weightedEL.groom$givingID, numscans$id)] + numscans$freq[match(weightedEL.groom$receivingID, numscans$id)])/2
weightedEL.groom$weight <- round(weightedEL.groom$count / weightedEL.groom$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.groom$weight[weightedEL.groom$weight>0]) #compute nonzero mean weight
weightedEL.groom$weight <- weightedEL.groom$weight/meanweight
el = weightedEL.groom[,c("givingID","receivingID",'weight'),]; #newP[,c("givingID","receivingID",'count'),]
adjMat = dils::AdjacencyFromEdgelist(el)# create adjacency matrix based on edge list.
mat = adjMat[["adjacency"]]; rownames(mat) = adjMat[["nodelist"]]; colnames(mat) = adjMat[["nodelist"]]
net<-as.network.matrix(mat,loops=FALSE,directed=T)
#set kinshp as edge attribute
KC      <- NULL; for(i in 1:length(el[,1])){
KC[i] <-  ped[which(rownames(ped)==as.character(el$receivingID[i])) , which(colnames(ped)==as.character(el$givingID[i]))]
}
set.edge.attribute(net, "kinship",KC)
#set proximity as edge attribute
prox <-NULL; for(i in 1:nrow(el)){
prox[i]<- el.prox$weight[which(el.prox$givingID==el$givingID[i] & el.prox$receivingID==el$receivingID[i])]
}
set.edge.attribute(net, "prox",prox)
#set sex as vertex attribute
sex = as.character(rscans$sex[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
set.vertex.attribute(net,"sex", sex)
#set age as vertex attribute
age = as.numeric(rscans$age[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
set.vertex.attribute(net,"age", age)
#set rank as vertex attribute
rank = as.numeric(rscans$percentrank[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
if (length(which(is.na(rank)))!=0){rank[which(is.na(rank))]=runif(length(which(is.na(rank))), min=0, max=100)}
set.vertex.attribute(net,"rank", rank)
SocialCapital = SocialCapital.ALL[which(SocialCapital.ALL$groupyear==groupyears[gy]),]
# Set PRE-HURRICANE standard Groom Strength as vertex attribute
groom = as.numeric(SocialCapital$std.DSIgroom[match(as.character(net %v% "vertex.names"), as.character(SocialCapital$id))])
set.vertex.attribute(net,"groom", groom)
# Set PRE-HURRICANE standard number of partners as vertex attrbute
numP = as.numeric(SocialCapital$std.numPartnersGroom[match(as.character(net %v% "vertex.names"), as.character(SocialCapital$id))])
set.vertex.attribute(net,"numP", numP)
if(isPost[h]==0){net.pre=net}
if(isPost[h]==1){net.post=net}
}
prePostList = list(net.pre, net.post)
prePostNet <- networkDynamic(network.list=prePostList)
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
set.network.attribute(net, "kinship",KC)
set.network.attribute(net, "prox",prox)
net
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
# 2. For each group, each year and pre-/post-hurr separately, compute weighted edge list:
gy=1
for (gy in 1:length(groupyears)){ #For each group
randscansY = randomScans[which(randomScans$groupyear==groupyears[gy]),] #subselect scans of group G
isPost = c(0,1); h=1
for (h in 1:length(isPost)){ #pre- and post-hurricane
rscans = randscansY[which(randscansY$isPost==isPost[h]),] #subselect scans of group G, year Y and hurricane status H
numscans = as.data.frame(table(as.character(rscans$focalID))); names(numscans) =c("id","freq")
#Find all unique IDs
unqIDs = unique(as.character(rscans$focalID))
# Output the Master Edgelist of all possible pairs given the unique IDs.
masterEL = calcMasterEL_groom(unqIDs)
# Output weighted edgelist from the Master Edgelist.
options(warn = -1) #set options to ignore all warnings
weightedEL.prox = calcEdgeList(rscans,masterEL)
weightedEL.prox$numscans <- (numscans$freq[match(weightedEL.prox$givingID, numscans$id)] + numscans$freq[match(weightedEL.prox$receivingID, numscans$id)])/2
weightedEL.prox$weight <- round(weightedEL.prox$count / weightedEL.prox$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.prox$weight[weightedEL.prox$weight>0]) #compute nonzero mean weight
weightedEL.prox$weight <- weightedEL.prox$weight/meanweight
el.prox = weightedEL.prox[,c("givingID","receivingID",'weight'),];
#for grooming network
weightedEL.groom = calcEdgeList_groom(rscans,masterEL)
weightedEL.groom = weightedEL.groom[,c("givingID","receivingID","count")]
weightedEL.groom$conc = paste(weightedEL.groom$givingID, weightedEL.groom$receivingID, sep=".")
weightedEL.groom$numscans <- (numscans$freq[match(weightedEL.groom$givingID, numscans$id)] + numscans$freq[match(weightedEL.groom$receivingID, numscans$id)])/2
weightedEL.groom$weight <- round(weightedEL.groom$count / weightedEL.groom$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.groom$weight[weightedEL.groom$weight>0]) #compute nonzero mean weight
weightedEL.groom$weight <- weightedEL.groom$weight/meanweight
el = weightedEL.groom[,c("givingID","receivingID",'weight'),]; #newP[,c("givingID","receivingID",'count'),]
adjMat = dils::AdjacencyFromEdgelist(el)# create adjacency matrix based on edge list.
mat = adjMat[["adjacency"]]; rownames(mat) = adjMat[["nodelist"]]; colnames(mat) = adjMat[["nodelist"]]
net<-as.network.matrix(mat,loops=FALSE,directed=T)
#set kinshp as edge attribute
KC      <- NULL; for(i in 1:length(el[,1])){
KC[i] <-  ped[which(rownames(ped)==as.character(el$receivingID[i])) , which(colnames(ped)==as.character(el$givingID[i]))]
}
set.network.attribute(net, "kinship",KC)
#set proximity as edge attribute
prox <-NULL; for(i in 1:nrow(el)){
prox[i]<- el.prox$weight[which(el.prox$givingID==el$givingID[i] & el.prox$receivingID==el$receivingID[i])]
}
set.network.attribute(net, "prox",prox)
#set sex as vertex attribute
sex = as.character(rscans$sex[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
set.vertex.attribute(net,"sex", sex)
#set age as vertex attribute
age = as.numeric(rscans$age[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
set.vertex.attribute(net,"age", age)
#set rank as vertex attribute
rank = as.numeric(rscans$percentrank[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
if (length(which(is.na(rank)))!=0){rank[which(is.na(rank))]=runif(length(which(is.na(rank))), min=0, max=100)}
set.vertex.attribute(net,"rank", rank)
SocialCapital = SocialCapital.ALL[which(SocialCapital.ALL$groupyear==groupyears[gy]),]
# Set PRE-HURRICANE standard Groom Strength as vertex attribute
groom = as.numeric(SocialCapital$std.DSIgroom[match(as.character(net %v% "vertex.names"), as.character(SocialCapital$id))])
set.vertex.attribute(net,"groom", groom)
# Set PRE-HURRICANE standard number of partners as vertex attrbute
numP = as.numeric(SocialCapital$std.numPartnersGroom[match(as.character(net %v% "vertex.names"), as.character(SocialCapital$id))])
set.vertex.attribute(net,"numP", numP)
if(isPost[h]==0){net.pre=net}
if(isPost[h]==1){net.post=net}
}
prePostList = list(net.pre, net.post)
prePostNet <- networkDynamic(network.list=prePostList)
}
gy=1
randscansY = randomScans[which(randomScans$groupyear==groupyears[gy]),] #subselect scans of group G
isPost = c(0,1); h=1
for (h in 1:length(isPost)){ #pre- and post-hurricane
rscans = randscansY[which(randscansY$isPost==isPost[h]),] #subselect scans of group G, year Y and hurricane status H
numscans = as.data.frame(table(as.character(rscans$focalID))); names(numscans) =c("id","freq")
#Find all unique IDs
unqIDs = unique(as.character(rscans$focalID))
# Output the Master Edgelist of all possible pairs given the unique IDs.
masterEL = calcMasterEL_groom(unqIDs)
# Output weighted edgelist from the Master Edgelist.
options(warn = -1) #set options to ignore all warnings
weightedEL.prox = calcEdgeList(rscans,masterEL)
weightedEL.prox$numscans <- (numscans$freq[match(weightedEL.prox$givingID, numscans$id)] + numscans$freq[match(weightedEL.prox$receivingID, numscans$id)])/2
weightedEL.prox$weight <- round(weightedEL.prox$count / weightedEL.prox$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.prox$weight[weightedEL.prox$weight>0]) #compute nonzero mean weight
weightedEL.prox$weight <- weightedEL.prox$weight/meanweight
el.prox = weightedEL.prox[,c("givingID","receivingID",'weight'),];
#for grooming network
weightedEL.groom = calcEdgeList_groom(rscans,masterEL)
weightedEL.groom = weightedEL.groom[,c("givingID","receivingID","count")]
weightedEL.groom$conc = paste(weightedEL.groom$givingID, weightedEL.groom$receivingID, sep=".")
weightedEL.groom$numscans <- (numscans$freq[match(weightedEL.groom$givingID, numscans$id)] + numscans$freq[match(weightedEL.groom$receivingID, numscans$id)])/2
weightedEL.groom$weight <- round(weightedEL.groom$count / weightedEL.groom$numscans, 5) #add weight information by dividing by avg #observations for each ID pair
meanweight = mean(weightedEL.groom$weight[weightedEL.groom$weight>0]) #compute nonzero mean weight
weightedEL.groom$weight <- weightedEL.groom$weight/meanweight
el = weightedEL.groom[,c("givingID","receivingID",'weight'),]; #newP[,c("givingID","receivingID",'count'),]
adjMat = dils::AdjacencyFromEdgelist(el)# create adjacency matrix based on edge list.
mat = adjMat[["adjacency"]]; rownames(mat) = adjMat[["nodelist"]]; colnames(mat) = adjMat[["nodelist"]]
net<-as.network.matrix(mat,loops=FALSE,directed=T)
#set kinshp as edge attribute
KC      <- NULL; for(i in 1:length(el[,1])){
KC[i] <-  ped[which(rownames(ped)==as.character(el$receivingID[i])) , which(colnames(ped)==as.character(el$givingID[i]))]
}
set.network.attribute(net, "kinship",KC)
#set proximity as edge attribute
prox <-NULL; for(i in 1:nrow(el)){
prox[i]<- el.prox$weight[which(el.prox$givingID==el$givingID[i] & el.prox$receivingID==el$receivingID[i])]
}
set.network.attribute(net, "prox",prox)
#set sex as vertex attribute
sex = as.character(rscans$sex[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
set.vertex.attribute(net,"sex", sex)
#set age as vertex attribute
age = as.numeric(rscans$age[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
set.vertex.attribute(net,"age", age)
#set rank as vertex attribute
rank = as.numeric(rscans$percentrank[match(as.character(net %v% "vertex.names"), as.character(rscans$focalID))])
if (length(which(is.na(rank)))!=0){rank[which(is.na(rank))]=runif(length(which(is.na(rank))), min=0, max=100)}
set.vertex.attribute(net,"rank", rank)
SocialCapital = SocialCapital.ALL[which(SocialCapital.ALL$groupyear==groupyears[gy]),]
# Set PRE-HURRICANE standard Groom Strength as vertex attribute
groom = as.numeric(SocialCapital$std.DSIgroom[match(as.character(net %v% "vertex.names"), as.character(SocialCapital$id))])
set.vertex.attribute(net,"groom", groom)
# Set PRE-HURRICANE standard number of partners as vertex attrbute
numP = as.numeric(SocialCapital$std.numPartnersGroom[match(as.character(net %v% "vertex.names"), as.character(SocialCapital$id))])
set.vertex.attribute(net,"numP", numP)
if(isPost[h]==0){net.pre=net}
if(isPost[h]==1){net.post=net}
}
prePostList = list(net.pre, net.post)
prePostNet <- networkDynamic(network.list=prePostList)
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
# constraints= ~bd(maxout = 7))
print(summary(mod))
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+edgecov("prox")+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+edgecov("kinship")+
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
print(summary(mod))
unlist(coef(mod)["formation"])
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+edgecov("prox")+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+edgecov("kinship")
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
# nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
# constraints= ~bd(maxout = 7))
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+edgecov("prox")+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+edgecov("kinship"),
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
# nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
# constraints= ~bd(maxout = 7))
print(summary(mod))
t<- try (mod<-stergm(prePostNet,
formation = ~edges+gwesp(decay=0.1, fixed=T)+mutual+
edgecov("kinship")+edgecov("prox"),#+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+
# nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
dissolution = ~edges+edgecov("kinship")+
# gwesp(decay=0.1, fixed=T)+mutual+
# nodecov("age")+nodecov("rank")+nodecov("groom")+nodecov("numP")+nodefactor("sex", base=1),
nodematch("sex",diff=TRUE)+absdiff("age")+absdiff("rank")+absdiff("groom")+absdiff("numP"),
estimate="CMLE"))
# constraints= ~bd(maxout = 7))
print(summary(mod))
